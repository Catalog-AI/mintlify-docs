---
title: "Building a Product Index"
description: "How to build and maintain your own product index using the Catalog API"
---

Build and maintain your own product index using Catalog's browse and product endpoints. Choose between vendor discovery or curating your own URL list.

<Note>
This guide covers both approaches: discovering products via [List Vendors](/api-reference/endpoints/browse/list-vendors) and collections, or indexing a self-selected set of URLs via [Get Products](/api-reference/endpoints/products/get-products).
</Note>

## Option 1: Build an index from vendors and collections

This approach is best when you want to keep an up-to-date index for many products from specific vendors.

### Step 1: Discover vendors

Use the **List Vendors** endpoint to discover which vendors are available and how many products they have.

- **Endpoint**: `GET /v1/vendors`

You can use this to:
- Select a subset of vendors to index (e.g., only fashion brands).
- Prioritize vendors with a larger `product_count`.

### Step 2: Enumerate collections (optional)

If your chosen vendors support collections, you can use a collections/browse endpoint to:

- Retrieve collections (e.g., “New In”, “Sale”, “Shoes”).
- Decide which collections to index (e.g., only “New Arrivals” or “Top Sellers”).

This helps you build a more structured index (vendor → collection → products).

### Step 3: List products per vendor or collection

Use the relevant browse endpoints (e.g., listings by vendor or by collection) to:

- Page through all products for a vendor or collection.
- Extract the **canonical product URLs** from each listing.

As you page through:
- Store product URLs in your own database or search index.
- Record lightweight metadata (vendor, handle/slug, collection, timestamps) for faster lookups.

### Step 4: Hydrate full product data

Once you have a list of product URLs, use:

- **Single product**: `POST /v1/product`  
  to hydrate full details for a specific URL.
- **Multiple products**: `POST /v1/products`  
  to hydrate many URLs in a single request.

Typical flow:

1. Pull a batch of URLs from your queue or DB.
2. Call `POST /v1/products` with up to the allowed maximum URLs.
3. For each result:
   - If `success === true` (or `meta.found === true` for single product):
     - Upsert the product into your index (search engine, DB, vector store, etc.).
   - If `success === false` or `meta.found === false`:
     - Optionally log the `outcome`/reason and decide whether to retry later.

You can repeat this process on a schedule (e.g., every few hours) to keep your index fresh.

## Option 2: Build an index from self-selected URLs

If you already know exactly which products you care about (e.g., from your own catalog, affiliate links, or a curated list), you can skip vendor/collection discovery and index directly from URLs.

### Step 1: Maintain your own URL list

Store your curated URLs in your own system:

- Source them from:
  - Your internal product catalog.
  - Merchant feeds or affiliate feeds.
  - Hand-curated collections or campaigns.
- Track basic metadata:
  - URL, vendor, category, tags, last indexed time, etc.

### Step 2: Hydrate products via the product endpoints

Use the same product endpoints as above:

- `POST /v1/product` for on-demand, single-item lookups.
- `POST /v1/products` for bulk hydration or scheduled backfills.

Recommended pattern:

1. Take a batch of URLs that are:
   - New, or
   - Stale (e.g., last updated more than N hours/days ago).
2. Call `POST /v1/products` with:
   - `urls`: your batch of URLs
   - `enable_enrichment`: `true` if you want AI-enriched attributes
   - `country_code`: the appropriate locale (defaults to `"us"` if missing or invalid)
3. Upsert successful results into your index, and log or track failures by `outcome` for monitoring.

### Step 3: Keep your index fresh

To maintain a high-quality product index:

- **Schedule re-indexing**:
  - Periodically rehydrate URLs to capture price, availability, and content changes.
- **Monitor failures**:
  - Use `success` / `meta.found` and `outcome` to detect:
    - Non-product URLs
    - Unsupported vendors
    - Products that have been removed
- **Prune stale products**:
  - Remove (or downgrade) products that consistently fail to hydrate or are no longer available.

## Choosing an approach

- **Use vendors + collections** when:
  - You want broad coverage of a merchant or category.
  - You care about staying in sync with a store’s full catalog.

- **Use self-selected URLs** when:
  - You already know which products you care about.
  - You’re building curated experiences or integrating with your own catalog.

In practice, many integrations combine both:
- Discover new products via vendors and collections.
- Maintain a curated subset of URLs for high-value or featured products.

## Related endpoints

<CardGroup cols={2}>
  <Card title="List Vendors" icon="store" href="/api-reference/endpoints/browse/list-vendors">
    Discover available vendors
  </Card>
  <Card title="List Collections" icon="folder" href="/api-reference/endpoints/browse/list-collections">
    Browse vendor collections
  </Card>
  <Card title="List Listings" icon="list" href="/api-reference/endpoints/browse/list-listings">
    Get products from a vendor
  </Card>
  <Card title="Get Products" icon="box" href="/api-reference/endpoints/products/get-products">
    Bulk fetch product details
  </Card>
</CardGroup>