---
title: "Building a Product Index"
description: "How to build and maintain your own product index using the Catalog API"
---

Build and maintain your own product index using Catalog's browse and product endpoints. Choose between vendor discovery or curating your own URL list.

<Note>
This guide covers both approaches: discovering products via [Get Vendors](/v1/api-reference/endpoints/listings/get-vendors) and collections, or indexing a self-selected set of URLs via [Get Products](/v1/api-reference/endpoints/products/retrieve-products).
</Note>

## Option 1: Build an index from vendors and collections

This approach is best when you want to keep an up-to-date index for many products from specific vendors.

### Step 1: Discover vendors

Use the **Get Vendors** endpoint (`GET /v1/vendors`) to discover which vendors are available and how many products they have.

You can use this to:
- Select a subset of vendors to index (e.g., only fashion brands)
- Prioritize vendors with a larger `product_count`

### Step 2: Enumerate collections (optional)

If your chosen vendors support collections, you can use the **Get Collections** endpoint to:
- Retrieve collections (e.g., "New In", "Sale", "Shoes")
- Decide which collections to index (e.g., only "New Arrivals" or "Top Sellers")

This helps you build a more structured index (vendor → collection → products).

### Step 3: List products per vendor or collection

Use the **Get All Products** endpoint to page through all products for a vendor or collection. As you page through:
- Extract the **canonical product URLs** from each listing
- Store product URLs in your own database or search index
- Record lightweight metadata (vendor, handle/slug, collection, timestamps) for faster lookups

### Step 4: Hydrate full product data

Once you have a list of product URLs, use the **Get Products** endpoint (`POST /v1/products`) to hydrate many URLs in a single request (1-1000 URLs per request).

**Typical flow:**

1. Pull a batch of URLs from your queue or database
2. Call `POST /v1/products` with up to 1000 URLs per request
3. Receive an `execution_id` and poll the [Get Execution Status](/v1/api-reference/endpoints/products/get-execution-status) endpoint
4. For each result in the completed execution:
   - If `success === true`: Upsert the product into your index (search engine, DB, vector store, etc.)
   - If `success === false`: Optionally log the `outcome`/reason and decide whether to retry later

You can repeat this process on a schedule (e.g., every few hours) to keep your index fresh.

## Option 2: Build an index from self-selected URLs

If you already know exactly which products you care about (e.g., from your own catalog, affiliate links, or a curated list), you can skip vendor/collection discovery and index directly from URLs.

### Step 1: Maintain your own URL list

Store your curated URLs in your own system. Source them from:
- Your internal product catalog
- Merchant feeds or affiliate feeds
- Hand-curated collections or campaigns

Track basic metadata such as URL, vendor, category, tags, and last indexed time.

### Step 2: Hydrate products via the product endpoints

Use the **Get Products** endpoint (`POST /v1/products`) for bulk hydration or scheduled backfills (supports 1-1000 URLs per request).

**Recommended pattern:**

1. Take a batch of URLs that are either:
   - New, or
   - Stale (e.g., last updated more than N hours/days ago)

2. Call `POST /v1/products` with:
   - `urls`: your batch of URLs (1-1000 per request)
   - `enable_enrichment`: `true` if you want AI-enriched attributes (default: `true`)
   - `country_code`: the appropriate locale (defaults to `"us"` if missing or invalid)

3. Poll the execution status endpoint until completion, then:
   - Upsert successful results into your index
   - Log or track failures by `outcome` for monitoring

### Step 3: Keep your index fresh

To maintain a high-quality product index:

**Schedule re-indexing:** Periodically rehydrate URLs to capture price, availability, and content changes.

**Monitor failures:** Use `success` and `outcome` to detect:
- Non-product URLs
- Unsupported vendors
- Products that have been removed

**Prune stale products:** Remove (or downgrade) products that consistently fail to hydrate or are no longer available.

## Choosing an approach

**Use vendors + collections** when:
- You want broad coverage of a merchant or category
- You care about staying in sync with a store's full catalog

**Use self-selected URLs** when:
- You already know which products you care about
- You're building curated experiences or integrating with your own catalog

In practice, many integrations combine both approaches:
- Discover new products via vendors and collections
- Maintain a curated subset of URLs for high-value or featured products

## Related endpoints

<CardGroup cols={2}>
  <Card title="Get Vendors" icon="store" href="/v1/api-reference/endpoints/listings/get-vendors">
    Discover available vendors
  </Card>
  <Card title="Get Collections" icon="folder" href="/v1/api-reference/endpoints/listings/get-collections">
    Browse vendor collections
  </Card>
  <Card title="Get All Products" icon="list" href="/v1/api-reference/endpoints/listings/get-products">
    Get products from a vendor
  </Card>
  <Card title="Get Products" icon="box" href="/v1/api-reference/endpoints/products/retrieve-products">
    Bulk fetch product details
  </Card>
</CardGroup>
