---
title: "Rate Limits"
description: "Understand Catalog API rate limits and how to handle them"
---

The Catalog API implements rate limiting to ensure fair usage and maintain service reliability for all users.

## Current limits

| Tier | Requests per minute | Requests per day | Concurrent requests |
|------|---------------------|------------------|---------------------|
| Standard | 60 | 10,000 | 10 |
| Pro | 300 | 100,000 | 50 |
| Enterprise | Custom | Custom | Custom |

<Note>
Rate limits are applied per API key. Contact our team if you need higher limits for your use case.
</Note>

## Rate limit headers

Every API response includes headers to help you track your usage:

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests allowed in the current window |
| `X-RateLimit-Remaining` | Requests remaining in the current window |
| `X-RateLimit-Reset` | Unix timestamp when the rate limit resets |
| `Retry-After` | Seconds to wait before retrying (only on 429 responses) |

## Handling rate limits

When you exceed the rate limit, the API returns a `429 Too Many Requests` response:

```json
{
  "error": {
    "code": "RATE_LIMITED",
    "message": "Rate limit exceeded. Please retry after 30 seconds."
  }
}
```

### Best practices

<Steps>
  <Step title="Monitor rate limit headers">
    Check the `X-RateLimit-Remaining` header to proactively throttle requests before hitting limits.
  </Step>
  <Step title="Implement exponential backoff">
    When rate limited, wait and retry with increasing delays (1s, 2s, 4s, etc.).
  </Step>
  <Step title="Use bulk endpoints">
    Use `/api/products` to fetch multiple products in a single request instead of making individual calls.
  </Step>
  <Step title="Cache responses">
    Cache product data to reduce redundant API calls for frequently accessed items.
  </Step>
</Steps>

## Implementation example

<CodeGroup>

```javascript JavaScript
class RateLimitedClient {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.remaining = null;
    this.resetTime = null;
  }

  async request(endpoint, options = {}) {
    // Check if we should wait
    if (this.remaining === 0 && this.resetTime) {
      const waitTime = this.resetTime - Date.now();
      if (waitTime > 0) {
        console.log(`Rate limited. Waiting ${waitTime}ms...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }

    const response = await fetch(`https://api.getcatalog.ai${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': this.apiKey,
        ...options.headers
      }
    });

    // Update rate limit tracking
    this.remaining = parseInt(response.headers.get('X-RateLimit-Remaining') || '60');
    const resetHeader = response.headers.get('X-RateLimit-Reset');
    this.resetTime = resetHeader ? parseInt(resetHeader) * 1000 : null;

    // Handle rate limit response
    if (response.status === 429) {
      const retryAfter = parseInt(response.headers.get('Retry-After') || '60');
      console.log(`Rate limited. Retrying in ${retryAfter}s...`);
      await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
      return this.request(endpoint, options);
    }

    return response.json();
  }
}

// Usage
const client = new RateLimitedClient('YOUR_API_KEY');
const results = await client.request('/v1/search', {
  method: 'POST',
  body: JSON.stringify({ query: 'summer dress' })
});
```

```python Python
import time
import requests

class RateLimitedClient:
    def __init__(self, api_key):
        self.api_key = api_key
        self.remaining = None
        self.reset_time = None
    
    def request(self, endpoint, method='GET', json_data=None):
        # Check if we should wait
        if self.remaining == 0 and self.reset_time:
            wait_time = self.reset_time - time.time()
            if wait_time > 0:
                print(f'Rate limited. Waiting {wait_time:.1f}s...')
                time.sleep(wait_time)
        
        response = requests.request(
            method,
            f'https://api.getcatalog.ai{endpoint}',
            headers={
                'Content-Type': 'application/json',
                'x-api-key': self.api_key
            },
            json=json_data
        )
        
        # Update rate limit tracking
        self.remaining = int(response.headers.get('X-RateLimit-Remaining', 60))
        reset_header = response.headers.get('X-RateLimit-Reset')
        self.reset_time = int(reset_header) if reset_header else None
        
        # Handle rate limit response
        if response.status_code == 429:
            retry_after = int(response.headers.get('Retry-After', 60))
            print(f'Rate limited. Retrying in {retry_after}s...')
            time.sleep(retry_after)
            return self.request(endpoint, method, json_data)
        
        return response.json()

# Usage
client = RateLimitedClient('YOUR_API_KEY')
results = client.request('/v1/search', method='POST', json_data={'query': 'summer dress'})
```

</CodeGroup>

## Optimizing API usage

### Use bulk endpoints

Instead of fetching products one by one:

```javascript
// ❌ Inefficient - 50 requests
for (const url of productUrls) {
  const product = await fetch('/v1/product', { body: JSON.stringify({ url }) });
}
```

Use the bulk endpoint:

```javascript
// ✅ Efficient - 1 request
const products = await fetch('/api/products', {
  body: JSON.stringify({ urls: productUrls })
});
```

### Implement caching

Cache product data to reduce API calls:

```javascript
const cache = new Map();
const CACHE_TTL = 3600000; // 1 hour

async function getProduct(url) {
  const cached = cache.get(url);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  
  const response = await client.request('/v1/product', {
    method: 'POST',
    body: JSON.stringify({ url })
  });
  
  cache.set(url, { data: response, timestamp: Date.now() });
  return response;
}
```

## Requesting higher limits

If you need higher rate limits, [contact our team](mailto:founders@getcatalog.ai) with:

- Your current API key
- Expected request volume (requests per minute/day)
- Your use case description

<Tip>
Enterprise plans include custom rate limits, dedicated support, and SLA guarantees.
</Tip>

